mapping scheme
bootstrap gdt
bootstrap system allocator
acpi parsing
lapic counting
find highest memory address
find first satisfactory region
free page bitmap
parse memory map
mark bitmap as allocated
page frame allocator
qemu exit codes
fix pfa bitmap
split system stacks into interrupt stacks, per-process system stacks, and a bootstrap stack
gdt structures for dynamic allocation
custom bootstrap gdt
paging structures & functions
process control block
track page mappings for each process
track ownership of and page frame ownership for messages
track ownership of processes by parent processes
create filesystem servers
track ownership of filesystem servers & messages
solidify syscall interface
system stacks
implement userspace-kernelspace separation for preemption in proc.rs
managed page tables for processes
change interface to accept an array of u64s, and return an array of options of u64s, and handle abort / map / unmap / switch within memory.rs
add type checks for message verification, exchanger state, copied -> sender verified -> sender inspected -> responder verified -> responder inspected message state
move from deserialising and reserialising every message to zero-copy (abi allows for it; originally attempted but deemed too messy for first try at osdev)
// complete ^^
// to do \/ \/
implement inspection and injection for message types
create requester/responder enums for message types (use macros to merge them?)
limit architecture-dependency to task.rs
kickstart process elf loader
boilerplate kickstart process
task initialisation
syscall testing
bucket cascade eevdf scheduler
rewrite ABI.md
traversal of filesystems in a tree by string
kernel tasks & servers
add back x86_64 crate for x86_64 port i/o
kernel server for x86_64 ports
kernel ostd println server
userspace hello world program
system-owned process server
set of default mounts into kickstart namespace
userspace elf loader
system-owned irq filesystem
ps2 keyboard server
atapio driver
fat32 driver
framebuffer server
console server
shell
ps2 mouse server
framebuffer + mouse + keyboard multiplexer
multicore schedulers
ap trampoline
initialise all other processors to scheduler
calculate priorities of processes based on heirarchy
lazy allocation for mapped pages
copy-on-write for sent pages
floating-point context switching
8-pcid cache